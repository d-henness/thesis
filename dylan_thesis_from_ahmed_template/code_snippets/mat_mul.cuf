module mat_mul
  implicit none
  integer, parameter  ::  dp = kind(0.d0)
  integer, parameter  ::  block_dim = 16
  integer, constant ::  rowA, colA, rowB, colB
  contains
    attributes(global) subroutine mat_mul_kernel(inputA, inputB, output)
      real(dp), dimension(:,:)  ::  inputA, inputB, output
      real(dp)  ::  total
      real(dp), shared, dimension(block_dim, block_dim) ::  s_tileA, s_tileB
      integer ::  x, y, i, j

      x = threadIdx%x + blockDim%x * (blockIdx%x - 1)
      y = threadIdx%y + blockDim%y * (blockIdx%y - 1)
      total = 0.0_dp

      do i = 0, colA - 1, block_dim
        call syncthreads()
        if ((x <= rowA) .and. (threadIdx%y + i <= colA)) then
          s_tileA(threadIdx%x, threadIdx%y) = inputA(x, threadIdx%y + i)
        else
          s_tileA(threadIdx%x, threadIdx%y) = 0.0_dp
        endif

        if ((threadIdx%x + i <= rowB) .and. (y <= colB)) then
          s_tileB(threadIdx%x, threadIdx%y) = inputB(threadIdx%x + i, y)
        else
          s_tileB(threadIdx%x, threadIdx%y) = 0.0_dp
        endif

        call syncthreads()

        do j = 1, block_dim
          total = total + s_tileA(threadIdx%x, j) * s_tileB(j, threadIdx%y)
        enddo

      enddo

      if((x <= rowA) .and. (y <= colB)) then
        output(x, y) = total
      endif
    end subroutine mat_mul_kernel
end module mat_mul

program main
  use cudafor
  use mat_mul
  implicit none
  ! Host variables
  real(dp), allocatable, dimension(:, :)  ::  inputA, inputB, output
  ! Device variables
  real(dp), device, allocatable, dimension(:, :)  ::  d_inputA, d_inputB, d_output
  ! For generating random numbers
  integer, allocatable, dimension(:)  ::  seed
  integer ::  n
  ! block and grid dimensions
  type(dim3)  ::  blockDim, gridDim

  rowA = 1024
  colA = 432
  rowB = colA
  colB = 1783

  ! Set up random number generator
  call random_seed(size = n)
  allocate(seed(n))
  ! Set seed to a constant so we always get the same matrices
  seed = 150987
  call random_seed(put = seed)
  deallocate(seed)
  
  ! Allocate host matrices and set up matrices
  allocate(inputA(rowA, colA))
  allocate(inputB(rowB, colB))
  allocate(output(rowA, colB))
  
  call random_number(inputA)
  call random_number(inputB)

  ! Allocate and upload device data
  allocate(d_inputA(rowA, colA))
  allocate(d_inputB(rowB, colB))
  allocate(d_output(rowA, colB))
  d_inputA = inputA
  d_inputB = inputB

  blockDim = dim3(block_dim, block_dim, 1)
  gridDim = dim3((rowA - 1) / block_dim + 1, (colB - 1) / block_dim + 1, 1)

  call mat_mul_kernel <<<gridDim, blockDim>>> (d_inputA, d_inputB, d_output)

  ! Download device data
  output = d_output

  ! Deallocate variables
  deallocate(d_inputA)
  deallocate(d_inputB)
  deallocate(d_output)
  deallocate(inputA)
  deallocate(inputB)
  deallocate(output)
end program main
